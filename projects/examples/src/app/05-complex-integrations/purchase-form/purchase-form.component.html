<section class="form-section">
  <div class="form-section-description">
    This complex purchase form demonstrates advanced form validation patterns
    and dynamic behavior:
  </div>
  <ul class="info-box-list">
    <li>Show validation errors on blur</li>
    <li>Show validation errors on submit</li>
    <li>When first name is <strong>Brecht</strong>: Set gender to male</li>
    <li>
      When first name is <strong>Brecht</strong> and last name is
      <strong>Billiet</strong>: Set age and passwords
    </li>
    <li>
      When first name is <strong>Luke</strong>: Fetch
      <strong>Luke Skywalker from the swapi api</strong>
    </li>
    <li>When age is below 18, make Emergency contact required</li>
    <li>When age is of legal age, disable Emergency contact</li>
    <li>There should be at least one phone number</li>
    <li>Phone numbers should not be empty</li>
    <li>When gender is <strong>other</strong>, show Specify gender</li>
    <li>When gender is <strong>other</strong>, make Specify gender required</li>
    <li>Password is required</li>
    <li>Confirm password is only required when password is filled in</li>
    <li>Passwords should match, but only check if both are filled in</li>
    <li>Billing address is required</li>
    <li>Show shipping address only when needed (otherwise remove from DOM)</li>
    <li>
      If shipping address is different from billing address, make it required
    </li>
    <li>
      If shipping address is different from billing address, make sure they are
      not the same
    </li>
    <li>
      When providing shipping address and toggling the checkbox back and forth,
      make sure the state is kept
    </li>
    <li>
      When clicking the Fetch data button, load data, disable the form, and
      patch and re-enable the form
    </li>
    <li>When the user id is taken, perform async validation</li>
    <li>
      Try to set the firstName to Brecht lastName to Billiet, Now change the age
      to 30. It shows how we can do validations on the root
    </li>
  </ul>
  <button class="form-submit" (click)="fetchData()">Fetch data</button>
</section>
<section class="form-section">
  <h3 class="form-section-title">The value of the form</h3>
  <pre id="json-data" class="json-display">
    {{ vm.formValue() | json }}
  </pre>
</section>

@if (vm.errors[rootFormKey]) {
  <div
    class="mb-4 rounded-lg bg-red-50 p-4 text-sm text-red-800 dark:bg-gray-800 dark:text-red-400"
    role="alert"
  >
    <ul>
      @for (error of vm.errors[rootFormKey]; track error) {
        <li>{{ error }}</li>
      }
    </ul>
  </div>
}

<!--
  ngx-vest-forms Example: Purchase Form

  Using the recommended two-way binding with Angular's model() API.
  <form ngxVestForm [(formValue)]="formValue"> ... </form>
-->

<form
  class="form-container"
  ngxVestForm
  #vestForm="ngxVestForm"
  (ngSubmit)="onSubmit()"
  [formSchema]="purchaseFormSchema"
  [(formValue)]="purchaseFormModel"
  [validationConfig]="validationConfig"
  [validationOptions]="{ debounceTime: 300 }"
  [vestSuite]="purchaseFormSuite"
>
  <fieldset [disabled]="vm.loading">
    <!-- Debug section for form state -->
    <div class="debug-box">
      <div>
        <span class="font-semibold">Form Valid:</span>
        {{ vestForm.formState().valid }}
      </div>
      <div>
        <span class="font-semibold">Form Pending: </span>
        {{ vestForm.formState().pending }}
      </div>
      <div>
        <span class="font-semibold">Form Dirty: </span>
        {{ vestForm.formState().dirty }}
      </div>
      <div>
        <span class="font-semibold">Form Status: </span>
        {{ vestForm.formState().status }}
      </div>
    </div>

    @if (vestForm.formState().dirty && !vestForm.formState().valid) {
      <div class="error-box">
        <h4 class="form-section-title">
          Please fix the form errors before submitting
        </h4>
      </div>
    }

    <section class="form-section">
      <h2 class="form-section-title">Personal Information</h2>

      <ngx-control-wrapper class="form-group">
        <label for="userId">User id</label>
        <input
          id="userId"
          placeholder="Type user id"
          type="text"
          [validationOptions]="{ debounceTime: 500 }"
          [ngModel]="vm.formValue().userId"
          name="userId"
        />
      </ngx-control-wrapper>

      <ngx-control-wrapper class="form-group" #firstNameWrapper>
        <label for="firstName">First name</label>
        <input
          id="firstName"
          placeholder="Type your first name"
          type="text"
          [ngModel]="vm.formValue().firstName"
          name="firstName"
          #firstNameControl="ngModel"
        />
      </ngx-control-wrapper>

      <!-- Debug for firstName control -->
      <div class="debug-info">
        <div>
          <span class="font-semibold">Control state:</span> Valid:
          {{ firstNameControl.valid }}, Touched: {{ firstNameControl.touched }},
          Dirty: {{ firstNameControl.dirty }}
        </div>
        <div>
          <span class="font-semibold">Control errors:</span>
          {{ firstNameControl.errors | json }}
        </div>
      </div>

      <ngx-control-wrapper class="form-group">
        <label for="lastName">Last name</label>
        <input
          id="lastName"
          placeholder="Type your last name"
          type="text"
          [ngModel]="vm.formValue().lastName"
          name="lastName"
        />
      </ngx-control-wrapper>

      <ngx-control-wrapper class="form-group">
        <label for="age">Age</label>
        <input
          id="age"
          placeholder="Choose your age"
          type="number"
          [ngModel]="vm.formValue().age"
          name="age"
        />
      </ngx-control-wrapper>

      <ngx-control-wrapper class="form-group">
        <label for="emergencyContact">Emergency contact</label>
        <input
          id="emergencyContact"
          placeholder="Type your emergency contact"
          type="text"
          [disabled]="vm.emergencyContactDisabled"
          [ngModel]="vm.formValue().emergencyContact"
          name="emergencyContact"
        />
      </ngx-control-wrapper>
    </section>

    <section class="form-section">
      <ngx-control-wrapper class="form-group" ngModelGroup="phoneNumbers">
        <ngx-phone-numbers [values]="vm.formValue().phoneNumbers.values" />
      </ngx-control-wrapper>
    </section>
    <section class="form-section">
      <h2 class="form-section-title">Gender</h2>
      <ngx-control-wrapper class="form-group">
        <span>Gender</span>
        <div class="radio-group">
          <div class="radio-button">
            <input
              id="gender-male"
              type="radio"
              [ngModel]="vm.formValue().gender"
              name="gender"
              value="male"
            />
            <label for="gender-male">Male</label>
          </div>
          <div class="radio-button">
            <input
              id="gender-female"
              type="radio"
              [ngModel]="vm.formValue().gender"
              name="gender"
              value="female"
            />
            <label for="gender-female">Female</label>
          </div>
          <div class="radio-button">
            <input
              id="gender-other"
              type="radio"
              [ngModel]="vm.formValue().gender"
              name="gender"
              value="other"
            />
            <label for="gender-other">Other</label>
          </div>
        </div>
      </ngx-control-wrapper>
      @if (vm.showGenderOther) {
        <ngx-control-wrapper class="form-group">
          <label for="genderOther">Specify gender</label>
          <input
            id="genderOther"
            type="text"
            [ngModel]="vm.formValue().genderOther"
            name="genderOther"
          />
        </ngx-control-wrapper>
      }
    </section>

    <section class="form-section">
      <h2 class="form-section-title">Password</h2>
      <ngx-control-wrapper class="form-group" ngModelGroup="passwords">
        <div class="form-row">
          <ngx-control-wrapper class="form-group">
            <label for="password">Password</label>
            <input
              id="password"
              placeholder="Type password"
              type="password"
              [ngModel]="vm.formValue().passwords.password"
              name="password"
              #passwordControl="ngModel"
            />
            <!-- Debug for password control -->
            <div class="debug-info">
              <div>Valid: {{ passwordControl.valid }}</div>
              <div>Touched: {{ passwordControl.touched }}</div>
              <div>Dirty: {{ passwordControl.dirty }}</div>
            </div>
          </ngx-control-wrapper>

          <ngx-control-wrapper class="form-group">
            <label for="confirmPassword">Confirm</label>
            <input
              id="confirmPassword"
              placeholder="Confirm password"
              type="password"
              [ngModel]="vm.formValue().passwords.confirmPassword"
              name="confirmPassword"
              #confirmPasswordControl="ngModel"
            />
            <!-- Debug for confirm password control -->
            <div class="debug-info">
              <div>Valid: {{ confirmPasswordControl.valid }}</div>
              <div>Touched: {{ confirmPasswordControl.touched }}</div>
              <div>Dirty: {{ confirmPasswordControl.dirty }}</div>
            </div>
          </ngx-control-wrapper>
        </div>
      </ngx-control-wrapper>
    </section>

    <section class="form-section">
      <h2 class="form-section-title">Product Selection</h2>
      <ngx-control-wrapper class="form-group">
        <label for="productId">Product</label>
        <select
          id="productId"
          name="productId"
          [ngModel]="vm.formValue().productId"
        >
          @for (product of products(); track product.id) {
            <option [value]="product.id">{{ product.name }}</option>
          }
        </select>
      </ngx-control-wrapper>
    </section>
    <section class="form-section">
      <h2 class="form-section-title">Addresses</h2>
      <ngx-control-wrapper class="form-group" ngModelGroup="addresses">
        <ngx-control-wrapper ngModelGroup="billingAddress">
          <h3 class="form-subsection-title">Billing address</h3>
          <ngx-address
            [address]="vm.formValue().addresses.billingAddress"
          ></ngx-address>
        </ngx-control-wrapper>

        <ngx-control-wrapper class="form-group">
          <label for="shippingAddressDifferentFromBillingAddress">
            <input
              id="shippingAddressDifferentFromBillingAddress"
              type="checkbox"
              [ngModel]="
                vm.formValue().addresses
                  .shippingAddressDifferentFromBillingAddress
              "
              name="shippingAddressDifferentFromBillingAddress"
            />
            <span>Shipping address is different from billing address</span>
          </label>
        </ngx-control-wrapper>

        @if (vm.showShippingAddress) {
          <ngx-control-wrapper ngModelGroup="shippingAddress">
            <h3 class="form-subsection-title">Shipping Address</h3>
            <ngx-address [address]="vm.shippingAddress"></ngx-address>
          </ngx-control-wrapper>
        }
      </ngx-control-wrapper>
    </section>

    <section class="form-section">
      <div class="form-actions">
        <button type="button" (click)="resetForm()">Reset</button>
        <button type="submit" [disabled]="!vestForm.formState().valid">
          Submit
        </button>
      </div>
    </section>
  </fieldset>
</form>

<section class="form-section">
  <h2 class="form-section-title">Debug Information</h2>

  <!-- Control Wrapper Info -->
  <div class="debug-box">
    <h3 class="font-semibold">Control Wrapper Info:</h3>
    <p class="text-sm">
      Default error display mode: touchOrSubmit (show errors when control is
      touched OR form is submitted)
    </p>
    <p class="text-sm">
      If controls are marked as touched but errors aren't showing, check the
      error structure in vestSuite.
    </p>

    <!-- Direct Angular validation check -->
    <div class="mt-2">
      <h4 class="font-semibold">Manual Error Display (Angular):</h4>
      @if (firstNameControl.touched && firstNameControl.errors?.['errors']) {
        <div class="text-sm text-red-600">
          @for (error of firstNameControl.errors?.['errors']; track error) {
            <div>{{ error }}</div>
          }
        </div>
      }
    </div>

    <!-- Form State Summary -->
    <div class="mt-2">
      <h4 class="font-semibold">Form State Summary:</h4>
      <div class="debug-grid">
        <div>Valid: {{ vestForm.formState().valid }}</div>
        <div>Invalid: {{ vestForm.formState().invalid }}</div>
        <div>Dirty: {{ vestForm.formState().dirty }}</div>
        <div>Pending: {{ vestForm.formState().pending }}</div>
        <div>Status: {{ vestForm.formState().status }}</div>
        <div>Idle: {{ vestForm.formState().idle }}</div>
      </div>
    </div>
  </div>

  <div class="info-box">
    <h3 class="font-semibold">Form State API Demo:</h3>
    <div class="debug-grid">
      <div>
        <span class="font-medium">Valid:</span>
        {{ vestForm.formState().valid }}
      </div>
      <div>
        <span class="font-medium">Invalid:</span>
        {{ vestForm.formState().invalid }}
      </div>
      <div>
        <span class="font-medium">Dirty:</span>
        {{ vestForm.formState().dirty }}
      </div>
      <div>
        <span class="font-medium">Pending:</span>
        {{ vestForm.formState().pending }}
      </div>
      <div>
        <span class="font-medium">Status:</span>
        {{ vestForm.formState().status }}
      </div>
      <div>
        <span class="font-medium">Idle:</span> {{ vestForm.formState().idle }}
      </div>
    </div>
    <p class="form-section-description">
      The formState() API provides a unified way to access all form state
      values.
    </p>
  </div>

  <!-- Example: errorDisplayMode usage (explicitly set to on-submit) -->
  <div ngxControlWrapper errorDisplayMode="on-submit" class="form-group">
    <label for="userId" class="form-label">User ID (on-submit)</label>
    <input
      id="userId"
      name="userId"
      type="text"
      autocomplete="off"
      class="form-input"
      ngModel
      required
    />
    <!--
      With errorDisplayMode="on-submit", errors for this field will only appear after the form is submitted.
    -->
  </div>

  <!-- Example: errorDisplayMode with updateOn: 'submit' (errors only show after submit) -->
  <div
    ngxControlWrapper
    errorDisplayMode="on-blur-or-submit"
    class="form-group"
  >
    <label for="email3" class="form-label">Email (updateOn: submit)</label>
    <input
      id="email3"
      name="email3"
      type="email"
      autocomplete="off"
      class="form-input"
      ngModel
      required
      [ngModelOptions]="{ updateOn: 'submit' }"
    />
    <!--
      With updateOn: 'submit', errors for this field will only appear after the form is submitted,
      regardless of the errorDisplayMode setting.
    -->
  </div>
</section>
